/** Storing the string as UTF-16 in an "Int16Array". */
TSTOSC__String : TSTOSC__Object
{
    classvar <empty, <whitespace_chars ;
    var utf16_array, codepoint_length = nil ;

    *initClass
    {
        empty = TSTOSC__String.new() ;
        whitespace_chars = [
            0x0020, 0x0009, 0x000b, 0x000c, 0x00a0, 0xfeff,
            0x1680, 0x202f, 0x205f, 0x3000
        ]
    }

    /* This always create new things from "obj". */
    *new { |obj=""| ^super.new().initTSTOSC__String(obj) ; }
    *fromCharCode
    { |...arr|
        ^super.new().initTSTOSC__StringByUTF16Array(Int16Array.newFrom(
            arr.collect({ |n| if( n > 0xffff, { n & 0xffff }, { n } ).value ; })
        )) ;
    }
    *fromCodePoint
    { |...arr|
        ^super.new().initTSTOSC__StringByUTF16Array(Int16Array.newFrom(
            arr.insert(0, []).reduce({ |prev, curr|
                prev ++ if(curr < 0x10000,
                    [curr],
                    [0xd800 + (curr - 0x10000 >> 10), 0xdc00 + (curr - 0x10000 & 0x3ff)]
                ) ;
            })
        )) ;
    }
    *tstosc__fromUTF16Array { |arr| ^super.new().initTSTOSC__StringByUTF16Array(arr) ; }
    /* This always create new things from "obj". */
    initTSTOSC__String
    { |obj|
        ^if ( obj.isKindOf(TSTOSC__String),
            { obj.deepCopy() ; },
            { TSTOSC__String.tstosc__coercion(obj) ; }
        ) ;
    }
    initTSTOSC__StringByUTF16Array { |arr| codepoint_length = nil ; utf16_array = arr ; ^this ; }

    asString
    { var result = List.new(this.tstosc__length), c = nil, itor = this.tstosc__getCodepointIterator() ;
        while ( { (c = itor.next()) != nil }, {
            result.add(TSTOSC__String.tstosc__codepointToSCString(c)) ;
        }) ;
        ^result.join("") ;
    }
    tstosc__asInterpreterString { ^"\"" ++ this.asString() ++ "\"" ; }
    value
    { var result = List.new(this.tstosc__length), c = nil, itor = this.tstosc__getCodepointIterator() ;
        while ( { (c = itor.next()) != nil }, {
            result.add(TSTOSC__String.tstosc__codepointToNoEscSCString(c)) ;
        }) ;
        ^result.join("") ;
    }

    /** Check if the class gives out a SCString for their ".value". */
    *tstosc__alikeString { |obj| ^obj.isKindOf(String) ; }
    /* This is only for type conversion. So if "obj" is "TSTOSC__String", it will not be copied. */
    *tstosc__coercion
    { |obj|
        if ( obj.isKindOf(TSTOSC__String), { ^obj ; } ) ;
        ^TSTOSC__String.tstosc__fromSCString( case (
            { TSTOSC__String.tstosc__alikeString(obj) }, { obj.value ; },
            { obj == TSTOSC.undefined }, { "undefined" ; },
            { obj == TSTOSC.null }, { "null" ; },
            { obj == true }, { "true" ; },
            { obj == false }, { "false" ; },
        ) ) ;
    }
    *tstosc__fromSCString
    { |str| var b = nil, i = 0, result = List.new((str.size * 1.5).asInteger()), codepoint = nil ;
        var uint = { |b| b = b.asInteger() ; if ( b < 0, { b + 256 ; }, { b ; } ) } ;
        while ( { i < str.size }, {
            b = uint.(str[i]) ;
            codepoint = case (
                // 0x00 to 0x7F: Single-byte (ASCII) characters.
                { b < 0x80 },
                { i = i + 1 ; b ; },

                // 0xC0 to 0xDF: Two-byte characters.
                { b < 0xe0 },
                {
                    i = i + 2 ;
                    ((b & 0x1f) << 6)
                    | (uint.(str[i - 1]) & 0x3f) ;
                },

                // 0xE0 to 0xEF: Three-byte characters.
                { b < 0xf0 },
                {
                    i = i + 3 ;
                    ((b & 0x0f) << 12)
                    | ((uint.(str[i - 2]) & 0x3f) << 6)
                    | (uint.(str[i - 1]) & 0x3f) ;
                },

                // 0xF0 to 0xF7: Four-byte characters.
                { b < 0xff },
                {
                    i = i + 4 ;
                    ((b & 0x07) << 18)
                    | ((uint.(str[i - 3]) & 0x3f) << 12)
                    | ((uint.(str[i - 2]) & 0x3f) << 6)
                    | (uint.(str[i - 1]) & 0x3f) ;
                },
            ) ;

            case (
                // BMP: Directly yield as UTF-16 code unit.
                { codepoint < 0x10000 },
                { result.add(codepoint) ; },

                // Supplementary planes: Convert to UTF-16 surrogate pair.
                { codepoint < 0x110000 },
                {
                    codepoint = codepoint - 0x10000 ;
                    result.add(0xd800 + (codepoint >> 10)) ;
                    result.add(0xdc00 + (codepoint & 0x3ff)) ;
                }
            ) ;
        } ) ;
        ^super.new().initTSTOSC__StringByUTF16Array(Int16Array.newFrom(result)) ;
    }

    tstosc__getCodepointIterator /* Generated by AI; rewrote and checked with few examples */
    { var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        ^Routine.new({ var i = 0, first = nil, next = nil ; while ( { i < utf16_array.size }, {
            first = uint.(utf16_array[i]) ; next = utf16_array[i + 1] ;
            case (
                // (0xd800 <= first <= 0xdbff) && (0xdc00 <= next <= 0xdfff), then combine them.
                { TSTOSC.lazyAnd(
                    { (0xd800 <= first) && (first <= 0xdbff) },
                    { next != nil }, { next = uint.(next) ; (0xdc00 <= next) && (next <= 0xdfff) }
                ) },
                { i = i + 2 ; (((first - 0xd800) << 10 | (next - 0xdc00)) + 0x10000).yield ; },

                // Otherwise, return "first" alone.
                { i = i + 1 ; first.yield ; }
            ) ;
        } ) ; }) ;
    }
    tstosc__getReversedCodepointIterator /* Generated by AI; rewrote and checked with few examples */
    { var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        ^Routine.new({ var i = utf16_array.size - 1, first = nil, next = nil ; while ( { i >= 0 }, {
            // This "first" is "counting from back", so the index is greater than "next".
            first = uint.(utf16_array[i]) ; next = utf16_array[i - 1] ;
            case (
                // (0xd800 <= next <= 0xdbff) && (0xdc00 <= first <= 0xdfff), then combine them.
                { TSTOSC.lazyAnd(
                    { next != nil }, { next = uint.(next) ; (0xd800 <= next) && (next <= 0xdbff) },
                    { (0xdc00 <= first) && (first <= 0xdfff) }
                ) },
                { i = i - 2 ; (((next - 0xd800) << 10 | (first - 0xdc00)) + 0x10000).yield ; },

                // Otherwise, return "first" alone.
                { i = i - 1 ; first.yield ; }
            ) ;
        } ) ; }) ;
    }
    tstosc__getCodepointIndexIterator
    { var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        ^Routine.new({ var i = 0, first = nil, next = nil ; while ( { i < utf16_array.size }, {
            first = uint.(utf16_array[i]) ; next = utf16_array[i + 1] ;
            case (
                // (0xd800 <= first <= 0xdbff) && (0xdc00 <= next <= 0xdfff), then combine them.
                { TSTOSC.lazyAnd(
                    { (0xd800 <= first) && (first <= 0xdbff) },
                    { next != nil }, { next = uint.(next) ; (0xdc00 <= next) && (next <= 0xdfff) }
                ) },
                { [i, i + 1].yield ; i = i + 2 ; },

                // Otherwise, return "first" alone.
                { [i, i].yield ; i = i + 1 ; }
            ) ;
        } ) ; }) ;
    }
    tstosc__getReversedCodepointIndexIterator
    { var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        ^Routine.new({ var i = utf16_array.size - 1, first = nil, next = nil ; while ( { i >= 0 }, {
            // This "first" is "counting from back", so the index is greater than "next".
            first = uint.(utf16_array[i]) ; next = utf16_array[i - 1] ;
            case (
                // (0xd800 <= next <= 0xdbff) && (0xdc00 <= first <= 0xdfff), then combine them.
                { TSTOSC.lazyAnd(
                    { next != nil }, { next = uint.(next) ; (0xd800 <= next) && (next <= 0xdbff) },
                    { (0xdc00 <= first) && (first <= 0xdfff) }
                ) },
                { [i - 1, i].yield ; i = i - 2 ; },

                // Otherwise, return "first" alone.
                { [i, i].yield ; i = i - 1 ; }
            ) ;
        } ) ; }) ;
    }
    tstosc__getCodepointIndex
    { |index| var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        var first = nil, next = nil, i = 0 ;
        var findNext = {
            first = uint.(utf16_array[i]) ; next = utf16_array[i + 1] ;
            case (
                // (0xd800 <= first <= 0xdbff) && (0xdc00 <= next <= 0xdfff), then combine them.
                { TSTOSC.lazyAnd(
                    { (0xd800 <= first) && (first <= 0xdbff) },
                    { next != nil }, { next = uint.(next) ; (0xdc00 <= next) && (next <= 0xdfff) }
                ) },
                { i = i + 2 ; [i - 2, i - 1] ; },

                // Otherwise, return "first" alone.
                { i = i + 1 ; [i - 1, i - 1] ; }
            ) ;
        } ;

        index = this.tstosc__normIndex(index) ;
        if ( (index < 0) || (index >= utf16_array.size), { ^[nil, nil] ; } ) ;
        index.do({ findNext.() ; })
        ^findNext.() ;
    }
    *tstosc__codepointToSCString
    { |codepoint|
        // Alone surrogate
        if ( (0xd800 <= codepoint) && (codepoint <= 0xdfff), { ^"\\u" ++ codepoint.asHexString(4).toLower() ; } ) ;
        ^TSTOSC__String.tstosc__codepointToNoEscSCString(codepoint) ;
    }
    *tstosc__codepointToNoEscSCString
    { |codepoint|
        case (
            // 1-byte sequence: 0xxxxxxx
            { codepoint <= 0x7F },
            {
                ^String.newFrom([codepoint.asAscii()]) ;
            },

            // 2-byte sequence: 110xxxxx 10xxxxxx
            { codepoint <= 0x7FF },
            {
                ^String.newFrom([
                    (0xC0 + (codepoint >> 6)).asAscii(),
                    (0x80 + (codepoint & 0x3F)).asAscii()
                ]) ;
            },

            // 3-byte sequence: 1110xxxx 10xxxxxx 10xxxxxx
            { codepoint <= 0xFFFF },
            {
                ^String.newFrom([
                    (0xE0 + (codepoint >> 12)).asAscii(),
                    (0x80 + ((codepoint >> 6) & 0x3F)).asAscii(),
                    (0x80 + (codepoint & 0x3F)).asAscii()
                ]) ;
            },

            // 4-byte sequence: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            { codepoint <= 0x10FFFF },
            {
                ^String.newFrom([
                    (0xF0 + (codepoint >> 18)).asAscii(),
                    (0x80 + ((codepoint >> 12) & 0x3F)).asAscii(),
                    (0x80 + ((codepoint >> 6) & 0x3F)).asAscii(),
                    (0x80 + (codepoint & 0x3F)).asAscii()
                ]) ;
            }
        ) ;
    }
    tstosc__getUTF16Array { ^utf16_array ; }
    tstosc__normIndex { |i| i = i.value ; if( i >= 0, { ^i }, { ^this.tstosc__length + i } ) ; }
    tstosc__calcLength
    { var itor = this.tstosc__getCodepointIterator(), i = 0 ;
        while ( { itor.next() != nil }, { i = i + 1 ; } ) ;
        ^i ;
    }

    ++ { |obj| ^this.concat(obj) ; }

    at
    { |index| var itor = this.tstosc__getCodepointIterator(), c = nil ;
        if ( index == nil, { ^nil ; } ) ; index = this.tstosc__normIndex(index) ; index.do({ itor.next() ; }) ;
        c = itor.next() ;
        if ( c == nil, { ^nil ; } ) ; ^TSTOSC__String.tstosc__codepointToSCString(c) ;
    }
    charAt
    { |index| index = this.tstosc__normIndex(index) ;
        if ( (index < 0) || (index >= utf16_array.size),
            { ^TSTOSC__String.empty ; },
            { ^TSTOSC__String.fromCharCode(utf16_array[index]); }
        ) ;
    }
    charCodeAt
    { |index| var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ; index = this.tstosc__normIndex(index) ;
        if ( (index < 0) || (index >= utf16_array.size),
            { ^TSTOSC.nan ; },
            { ^TSTOSC__Number.new(uint.(utf16_array[index])); }
        ) ;
    }
    concat
    { |...strs|
        ^TSTOSC__String.tstosc__fromUTF16Array(
            ([this] ++ strs).collect({ |s| TSTOSC__String.new(s).tstosc__getUTF16Array() ; }).reduce(_ ++ _)
        ) ;
    }
    endsWith
    { |str, end_position=nil| var i = 0 ;
        end_position = this.tstosc__getCodepointIndex((end_position ? this.tstosc__length) - 1)[1] ;
        if ( or(end_position < 0, end_position >= this.tstosc__length), { ^false ; } ) ;
        str = TSTOSC__String.tstosc__coercion(str) ;
        str.tstosc__getUTF16Array().reverseDo({ |c|
            if ( c != utf16_array[end_position - i], { ^false ; } ) ;
            i = i + 1 ;
        }) ;
        ^true ;
    }
    tstosc__getCodepointIndexOfUTF16Array
    { |str_arr| var i = 0, j = 0 ;
        if ( str_arr.size == 0, { ^-1 ; } ) ;
        while ( { i < utf16_array.size }, {
            if ( utf16_array[i] == str_arr[j],
                { j = j + 1 ; },
                { j = if(utf16_array[i] == str_arr[0], { 1 ; }, { 0 ; }) ; }
            ) ;
            if ( j >= str_arr.size, { ^i - str_arr.size ; } ) ;
            i = i + 1 ;
        } ) ;
        ^-1 ;
    }
    includes
    { |str, start_position=0| var str_arr ;
        start_position = this.tstosc__getCodepointIndex(start_position)[0] ;
        if ( or(start_position < 0, start_position >= this.tstosc__length), { ^false ; } ) ;
        str_arr = TSTOSC__String.tstosc__coercion(str).tstosc__getUTF16Array() ;
        if ( str_arr.size == 0, { ^true ; } ) ;
        ^this.tstosc__getCodepointIndexOfUTF16Array(str_arr) >= 0 ;
    }
    indexOf
    { |str, start_position=0|
        start_position = this.tstosc__getCodepointIndex(start_position)[0] ;
        if ( or(start_position < 0, start_position >= this.tstosc__length), { ^-1 ; } ) ;
        str = TSTOSC__String.tstosc__coercion(str) ;
        if ( str.length == 0, { ^0 ; } ) ;
        ^this.tstosc__getCodepointIndexOfUTF16Array(str.tstosc__getUTF16Array()) ;
    }
    isWellFormed
    { var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        var first = nil, next = nil, i = 0 ;
        while ( { i < this.tstosc__length }, {
            first = uint.(utf16_array[i]) ; next = utf16_array[i + 1] ;
            case (
                { (0xd800 <= first) && (first <= 0xdbff) },
                {
                    if ( next == nil, { ^false ; } ) ; next = uint.(next) ;
                    if ( (next < 0xdc00) || (0xdfff < next), { ^false ; } ) ;
                    /* continue */ i = i + 2 ;
                },

                { (0xdc00 <= first) && (first <= 0xdfff) },
                { ^false ; },

                { /* otherwise continue */ i = i + 1 ; }
            ) ;
        } ) ;
        ^true ;
    }
    lastIndexOf
    { |str_arr| var i = utf16_array.size - 1, j = str_arr.size - 1 ;
        if ( str_arr.size == 0, { ^-1 ; } ) ;
        while ( { i >= 0 }, {
            if ( utf16_array[i] == str_arr[j],
                { j = j - 1 ; },
                { j = if(utf16_array[i] == str_arr[str_arr.size - 1], { str_arr.size - 2 ; }, { str_arr.size - 1 ; }) ; }
            ) ;
            if ( j < 0, { ^i ; } ) ;
            i = i - 1 ;
        } ) ;
        ^-1 ;
    }
    localeCompare /* TODO: Not impl-ed properly. */
    { |str, locales=nil, options=nil| var i = 0, min_length, str_arr ; var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        str_arr = TSTOSC__String.tstosc__coercion(str).tstosc__getUTF16Array() ;
        min_length = min(utf16_array.size, str_arr.size) ;
        while ( { i < min_length }, {
            if ( utf16_array[i] < str_arr[i], { ^-1 ; } ) ;
            if ( utf16_array[i] > str_arr[i], { ^1 ; } ) ;
            i = i + 1 ;
        } ) ;
        if ( utf16_array.size == str_arr.size, { ^0 ; } ) ;
        if ( utf16_array.size < str_arr.size, { ^-1 ; }, { ^1 ; } ) ;
    }
    /* match {  } */
    /* matchAll {  } */
    /* normalize { |form="NFC"| } */
    padEnd
    { |target_length, pad_string=" "| var remaining_length = target_length - this.tstosc__length ;
        pad_string = TSTOSC__String.tstosc__coercion(pad_string) ;
        if ( remaining_length <= 0, { ^this ; } ) ;
        ^TSTOSC__String.tstosc__fromUTF16Array(Int16Array.newFrom(
            this.tstosc__getUTF16Array()
            ++ Array.fill(
                floor(remaining_length / pad_string.length), { pad_string }
            ).collect(_.tstosc__getUTF16Array()).reduce(_ ++ _)
            ++ pad_string.slice(0, remaining_length % pad_string.length).tstosc__getUTF16Array()
        )) ;
    }
    slice
    { |start=nil, end=nil| var itor = nil, index_l = 0, index_r = 0 ; start = start ? 0 ; end = end ? this.tstosc__length ;
        start = TSTOSC__Number.tstosc__parseNumber(start) ; end = TSTOSC__Number.tstosc__parseNumber(end) ;
        if ( not(TSTOSC__Number.tstosc__alikeNumber(start)), { start = 0 ; } ) ;
        if ( not(TSTOSC__Number.tstosc__alikeNumber(end)), { end = 0 ; } ) ;
        start = this.tstosc__normIndex(start) ; end = this.tstosc__normIndex(end) ;

        if ( or(start >= this.length, end <= start), { ^TSTOSC__String.empty ; } ) ;
        end = min(end, this.tstosc__length) ;
        itor = this.tstosc__getCodepointIndexIterator() ;
        start.do({ itor.next() ; }) ;
        # index_l, index_r = itor.next() ;
        // Only update "index_r" if "end - start >= 2".
        if ( end - start >= 2, { (end - start - 2).do({ itor.next() ; }) ; index_r = itor.next()[1] ; } ) ;
        ^TSTOSC__String.tstosc__fromUTF16Array(utf16_array.copyRange(index_l, index_r)) ;
    }
    startsWith
    { |str, start_position=nil| var i = 0 ;
        start_position = this.tstosc__getCodepointIndex(start_position ? 0)[0] ;
        if ( or(start_position < 0, start_position >= this.tstosc__length), { ^false ; } ) ;
        str = TSTOSC__String.tstosc__coercion(str) ;
        str.tstosc__getUTF16Array().do({ |c|
            if ( c != utf16_array[start_position + i], { ^false ; } ) ;
            i = i + 1 ;
        }) ;
        ^true ;
    }
    substring
    { |start=0, end=nil| end = end ? this.tstosc__length ;
        start = TSTOSC__Number.tstosc__parseNumber(start) ; end = TSTOSC__Number.tstosc__parseNumber(end) ;
        if ( or(not(TSTOSC__Number.tstosc__alikeNumber(start)), start < 0), { start = 0 ; } ) ;
        if ( or(not(TSTOSC__Number.tstosc__alikeNumber(end)), end < 0), { end = 0 ; } ) ;

        case (
            { start == end }, { ^TSTOSC__String.empty ; },
            { start >  end }, { ^this.slice(end, start) ; },
            { ^this.slice(start, end) ; }
        ) ;
    }
    /** TODO */
    toLocaleLowerCase
    {
        this.toLowerCase() ;
    }
    /** TODO */
    toLocaleUpperCase
    {
        this.toUpperCase() ;
    }
    toLowerCase { ^TSTOSC__String.tstosc__fromSCString(this.value.toLower()) ; }
    toString { ^this ; }
    toUpperCase { ^TSTOSC__String.tstosc__fromSCString(this.value.toUpper()) ; }
    toWellFormed
    { var result = List.new(this.tstosc__length), c = nil, itor = this.tstosc__getCodepointIterator() ;
        while ( { (c = itor.next()) != nil }, {
            if ( (0xd800 <= c) && (c <= 0xdfff), { c = 0xfffd ; } ) ;
            result.add(TSTOSC__String.tstosc__codepointToNoEscSCString(c)) ;
        }) ;
        ^result.join("") ;
    }
    tstosc__findFirstNonSpaceUTF16ArrayIndex
    { var itor = this.tstosc__getCodepointIndexIterator(), codepoint = nil, indexes = nil ;
        var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        while ( { (indexes = itor.next()) != nil }, {
            codepoint = if ( indexes[0] == indexes[1],
                utf16_array[indexes[0]],
                (((uint.(utf16_array[indexes[0]]) - 0xd800) << 10 | (uint.(utf16_array[indexes[1]]) - 0xdc00)) + 0x10000)
            ) ;
            case (
                { TSTOSC__String.whitespace_chars.includes(codepoint) }, { },
                { and(0x2000 <= codepoint, codepoint <= 0x200a) }, { },
                { ^indexes[0] ; }
            ) ;
        } ) ;
        ^utf16_array.size ;
    }
    tstosc__findLastNonSpaceUTF16ArrayIndex
    { var itor = this.tstosc__getReversedCodepointIndexIterator(), codepoint = nil, indexes = nil ;
        var uint = { |x| if (x < 0, { x + 0x10000 }, { x }) } ;
        while ( { (indexes = itor.next()) != nil }, {
            codepoint = if ( indexes[0] == indexes[1],
                utf16_array[indexes[0]],
                (((uint.(utf16_array[indexes[0]]) - 0xd800) << 10 | (uint.(utf16_array[indexes[1]]) - 0xdc00)) + 0x10000)
            ) ;
            case (
                { TSTOSC__String.whitespace_chars.includes(codepoint) }, { },
                { and(0x2000 <= codepoint, codepoint <= 0x200a) }, { },
                { ^indexes[1] ; }
            ) ;
        } ) ;
        ^-1 ;
    }
    trim
    {
        ^TSTOSC__String.tstosc__fromUTF16Array(utf16_array.copyRange(
            this.tstosc__findFirstNonSpaceUTF16ArrayIndex(),
            this.tstosc__findLastNonSpaceUTF16ArrayIndex()
        )) ;
    }
    trimEnd
    {
        ^TSTOSC__String.tstosc__fromUTF16Array(utf16_array.copyRange(
            0,
            this.tstosc__findLastNonSpaceUTF16ArrayIndex()
        )) ;
    }
    trimStart
    {
        ^TSTOSC__String.tstosc__fromUTF16Array(utf16_array.copyRange(
            this.tstosc__findFirstNonSpaceUTF16ArrayIndex(),
            utf16_array.size - 1
        )) ;
    }

    /** for JavaScript compatibility */
    valueOf { ^this ; }

    /* For properties */

    length { ^TSTOSC__Number.new(this.tstosc__length) ; }
    tstosc__length { ^codepoint_length ?? { codepoint_length = this.tstosc__calcLength() ; } ; }
}